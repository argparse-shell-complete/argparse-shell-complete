#!/usr/bin/python3

import os
import sys
import json
import argparse

from argparse_shell_complete import zsh, bash, fish, commandline, argparse_mod
from argparse_shell_complete import file_loader, argparse_source, json_source
from argparse_shell_complete import config as _config


def parse_bool(s):
    if s.lower() == 'true':
        return True
    if s.lower() == 'false':
        return False
    raise Exception("Not a bool: %r" % s)


p = argparse.ArgumentParser('argparse-shell-complete',
    description='Generate shell auto completion files')

p.add_argument('shell', choices=('bash', 'fish', 'zsh', 'json'),
    help='Specify the shell type for the completion script')

p.add_argument('source_file',
    help='The file containing the command line definitions').complete('file')

p.add_argument('--parser-variable', default=None,
    help='Specify the variable name of the ArgumentParser object')

p.add_argument('--allow-python', action='store_true', default=False,
    help='Allow python files as source')

p.add_argument('--program-name', default=None,
    help='Specify program name')

p.add_argument('--abbreviate-commands', default=False, type=parse_bool,
    help='Sets whether commands can be abbreviated')

p.add_argument('--abbreviate-options', default=False, type=parse_bool,
    help='Sets whether options can be abbreviated')

p.add_argument('--multiple-options', default=False, type=parse_bool,
    help='Sets whether options are suggested multiple times during completion')

p.add_argument('--inherit-options', default=False, type=parse_bool,
    help='Sets whether parent options are visible to subcommands')

p.add_argument('--vim-modeline', default=True, type=parse_bool,
    help='Sets whether a vim modeline comment shall be appended to the generated code')

p.add_argument('--zsh-compdef', default=True, type=parse_bool,
    help='Sets whether #compdef is used in zsh scripts')

p.add_argument('--fish-fast', default=False, type=parse_bool,
    help='Use faster commandline parsing at the cost of correctness')

p.add_argument('--fish-inline-conditions', default=False, type=parse_bool,
    help="Don't store conditions in a variable")

p.add_argument('--include-file', action='append',
    help='Include file in output').complete('file')

p.add_argument('--debug', action='store_true',
    help='Enable debug mode')

grp = p.add_mutually_exclusive_group()

grp.add_argument('-o', '--output', default=None,
    help='Write output to destination file [default: stdout]').complete('file')

grp.add_argument('-i', '--install-system-wide', default=False, action='store_true',
    help='Write output to the system wide completions dir of shell')

grp.add_argument('-u', '--uninstall-system-wide', default=False, action='store_true',
    help='Uninstall the system wide completion file for program')

# We use an unique object name for avoinding name clashes when
# importing/executing the foreign python script
_argparse_shell_complete_argument_parser = p
del p

def find_ArgumentParser(module):
    found_parsers = []

    for obj_name in dir(module):
        obj = getattr(module, obj_name)
        if isinstance(obj, argparse.ArgumentParser) and obj is not _argparse_shell_complete_argument_parser:
            found_parsers.append(obj)

    if len(found_parsers) == 1:
        return found_parsers[0]
    elif len(found_parsers) > 1:
        # Find root parser
        # TODO: this doesn't work well with multiple subcommands ("prog cmd1 cmd2")
        for parser in found_parsers:
            if parser._subparsers is not None:
                return parser

    return None

def load_from_json(file):
    with open(file, 'r') as fh:
        return json_source.JSON_To_Commandline(json.load(fh))

def load_from_python(file, parser_variable=None):
    try:
        module = file_loader.import_file(file)
    except Exception as e:
        print(e)
        print("Warning: failed to load `%s` using importlib, falling back to `exec`" % file, file=sys.stderr)
        module = file_loader.execute_file(file)

    if parser_variable is not None:
        try:
            parser = getattr(module, parser_variable)
        except:
            raise Exception("No variable found named %r" % parser_variable)
    else:
        parser = find_ArgumentParser(module)

    if parser is None:
        raise Exception("Could not find any ArgumentParser object in `%s`" % file)

    return argparse_source.ArgumentParser_to_CommandLine(parser)

def generate(opts):
    if not os.path.exists(opts.source_file):
        raise FileNotFoundError(opts.source_file)

    if opts.shell == 'json':
        try:    cmdline = load_from_json(opts.source_file)
        except: cmdline = load_from_python(opts.source_file, opts.parser_variable)

        objs = json_source.CommandLine_To_JSON(cmdline)
        r = json.dumps(objs, indent=None)
        fh = open(opts.output, 'w') if opts.output else sys.stdout
        print(r, file=fh)
        return

    try:
        cmdline = load_from_json(opts.source_file)
    except:
        if opts.allow_python:
            cmdline = load_from_python(opts.source_file, opts.parser_variable)
        else:
            raise

    if opts.program_name is None:
        opts.program_name = cmdline.prog

    config = _config.Config()
    config.set_abbreviate_commands(opts.abbreviate_commands)
    config.set_abbreviate_options(opts.abbreviate_options)
    config.set_multiple_options(opts.multiple_options)
    config.set_inherit_options(opts.inherit_options)
    config.set_vim_modeline(opts.vim_modeline)
    config.set_zsh_compdef(opts.zsh_compdef)
    config.set_fish_fast(opts.fish_fast)
    config.set_fish_inline_conditions(opts.fish_inline_conditions)
    config.include_many_files(opts.include_file or [])

    r = {
        'bash': bash.generate_completion,
        'fish': fish.generate_completion,
        'zsh':  zsh.generate_completion
    }[opts.shell](cmdline, opts.program_name, config)

    if opts.install_system_wide is True or opts.uninstall_system_wide is True:
        file = {
            'bash': bash.get_completions_file,
            'fish': fish.get_completions_file,
            'zsh':  zsh.get_completions_file,
        }[opts.shell](opts.program_name)

        if opts.install_system_wide:
            print('Installing to %s' % file, file=sys.stderr)
            with open(file, 'w') as fh:
                fh.write(r)
        else:
            print('Removing %s' % file, file=sys.stderr)
            os.remove(file)

    elif opts.output is not None:
        with open(opts.output, 'w') as fh:
            fh.write(r)

    else:
        print(r)


if __name__ == '__main__':
    try:
        opts = _argparse_shell_complete_argument_parser.parse_args()
        generate(opts)
    except Exception as e:
        print('%s: %s' % (type(e).__name__, e), file=sys.stderr)
        if opts.debug:
            raise
        else:
            print('Pass --debug to see full stack trace', file=sys.stderr)
            sys.exit(1)
